<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NAND Pachinko</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <h1>NAND Pachinko</h1>
    <p class="description">
        Build an XOR gate using NAND gates! Connect nodes to create NAND gates and try to match the target outputs.
        Drag nodes to rearrange them, and connect them to create your circuit.
    </p>
    <div id="controls">
        <button id="reset-btn" onclick="resetGame()">Reset Circuit</button>
        <button onclick="addIntermediateNode()">Add Intermediate Node</button>
        <button id="play-btn" onclick="playAnimation()">Play Animation</button>
    </div>
    <div class="game-wrapper">
        <div class="circuit-info">
            <h2>Circuit Layout</h2>
            <div id="circuit-serialization"></div>
        </div>
        <div id="game-container">
            <div class="goal-display"></div>
        </div>
        <div class="truth-table">
            <h2>Truth Table</h2>
            <div id="truth-table-content"></div>
        </div>
    </div>

    <script>
        let selectedNode = null;
        let nodes = [];
        let connections = [];
        let tooltip = null;
        let nextNodeId = 2; // Start from 2 since output is 1
        let outputNodes = [];

        const GOALS = {
            xor: {
                description: 'XOR Gate: Output should be 1 when inputs are different',
                truthTable: [
                    { inputs: [0, 0], output: 0 },
                    { inputs: [0, 1], output: 1 },
                    { inputs: [1, 0], output: 1 },
                    { inputs: [1, 1], output: 0 }
                ]
            }
        };

        function updateCircuitSerialization() {
            const serializationDiv = document.getElementById('circuit-serialization');
            let serialization = '';
            
            // Helper function to find a node in either array
            const findNodeById = (id) => {
                return nodes.find(n => n.id === id) || 
                       outputNodes.find(n => n.id === id);
            };
            
            // Only show NAND gates with both inputs connected
            nodes.filter(n => n.dataset.type === 'nand' && n.dataset.input1 && n.dataset.input2).forEach(nand => {
                const input1 = findNodeById(nand.dataset.input1);
                const input2 = findNodeById(nand.dataset.input2);
                if (input1 && input2) {
                    serialization += `${input1.dataset.nodeId} ${input2.dataset.nodeId} ${nand.dataset.nodeId}<br>`;
                }
            });
            
            // Add output node connections if they exist
            outputNodes.forEach(output => {
                if (output.dataset.input1 && output.dataset.input2) {
                    const input1 = findNodeById(output.dataset.input1);
                    const input2 = findNodeById(output.dataset.input2);
                    if (input1 && input2) {
                        serialization += `${input1.dataset.nodeId} ${input2.dataset.nodeId} 1<br>`;
                    }
                }
            });
            
            serializationDiv.innerHTML = serialization;
        }

        function createNode(x, y, value, type) {
            const node = document.createElement('div');
            node.className = `node ${type}-node`;
            node.style.left = x + 'px';
            node.style.top = y + 'px';
            node.dataset.x = x;
            node.dataset.y = y;
            node.dataset.value = value;
            node.dataset.type = type;
            node.id = 'node-' + Math.random().toString(36).substr(2, 9);
            
            // Assign node ID
            if (type === 'output') {
                node.dataset.nodeId = '1';
                node.textContent = '1';
            } else {
                node.dataset.nodeId = nextNodeId.toString();
                node.textContent = nextNodeId.toString();
                nextNodeId++;
            }
            
            node.addEventListener('mousedown', startDragging);
            node.addEventListener('click', () => handleNodeClick(node));
            node.addEventListener('mousemove', (e) => showTooltip(node, e));
            node.addEventListener('mouseout', hideTooltip);
            
            document.getElementById('game-container').appendChild(node);
            if (type === 'output') {
                outputNodes.push(node);
            } else {
                nodes.push(node);
            }
            return node;
        }

        function createNandNode(input1, input2) {
            const x = (parseInt(input1.dataset.x) + parseInt(input2.dataset.x)) / 2;
            const y = Math.max(parseInt(input1.dataset.y), parseInt(input2.dataset.y)) + 80;
            const nand = createNode(x, y, '1', 'nand');
            nand.dataset.input1 = input1.id;
            nand.dataset.input2 = input2.id;
            updateNandValue(nand, input1, input2);
            updateCircuitSerialization();
            return nand;
        }

        function createTooltip() {
            tooltip = document.createElement('div');
            tooltip.className = 'tooltip';
            document.body.appendChild(tooltip);
        }

        function showTooltip(node, event) {
            const type = node.dataset.type === 'input' ? 'Input' : 
                        node.dataset.type === 'output' ? 'Target Output' : 'NAND';
            const value = node.dataset.value;
            tooltip.textContent = `${type} Node: ${value}`;
            tooltip.style.left = event.pageX + 10 + 'px';
            tooltip.style.top = event.pageY + 10 + 'px';
            tooltip.style.opacity = '1';
        }

        function hideTooltip() {
            if (tooltip) tooltip.style.opacity = '0';
        }

        function handleNodeClick(node) {
            if (!selectedNode) {
                // Don't allow selecting output node as source
                if (node.dataset.type === 'output') return;
                
                selectedNode = node;
                node.classList.add('selected');
            } else if (selectedNode !== node) {
                // Don't allow connecting to input nodes (the first two nodes) or from output nodes
                if (node.dataset.nodeId === '2' || node.dataset.nodeId === '3') {
                    selectedNode.classList.remove('selected');
                    selectedNode = null;
                    return;
                }
                
                if (node.dataset.type === 'output') {
                    // Handle connection to output node
                    if (!node.dataset.input1) {
                        node.dataset.input1 = selectedNode.id;
                    } else if (!node.dataset.input2) {
                        node.dataset.input2 = selectedNode.id;
                    }
                    drawConnection(selectedNode, node);
                    node.dataset.value = selectedNode.dataset.value; // Directly set value without propagation
                    checkCircuit();
                    updateTruthTable();
                    updateCircuitSerialization();
                    selectedNode.classList.remove('selected');
                    selectedNode = null;
                    return;
                }
                
                // Check if destination node already has 2 inputs
                const existingInputs = [];
                if (node.dataset.input1) existingInputs.push(node.dataset.input1);
                if (node.dataset.input2) existingInputs.push(node.dataset.input2);
                
                // Check for duplicate connections
                if (existingInputs.includes(selectedNode.id)) {
                    selectedNode.classList.remove('selected');
                    selectedNode = null;
                    return;
                }
                
                if (existingInputs.length < 2) {
                    // Add connection
                    if (!node.dataset.input1) {
                        node.dataset.input1 = selectedNode.id;
                    } else {
                        node.dataset.input2 = selectedNode.id;
                    }
                    drawConnection(selectedNode, node);
                    updateNandValue(node);
                    checkCircuit(); // Add check here after all updates are done
                    updateCircuitSerialization();
                    updateTruthTable();
                }
                selectedNode.classList.remove('selected');
                selectedNode = null;
            }
        }

        // Add click handler to game container to deselect when clicking empty space
        document.getElementById('game-container').addEventListener('click', function(e) {
            if (e.target === this && selectedNode) {
                selectedNode.classList.remove('selected');
                selectedNode = null;
            }
        });

        function updateOutputValue(outputNode) {
            const input1 = nodes.find(n => n.id === outputNode.dataset.input1);
            const input2 = nodes.find(n => n.id === outputNode.dataset.input2);
            
            if (input1) {
                outputNode.dataset.value = input1.dataset.value;
            }
            if (input2) {
                // If we have two inputs, use the most recent one
                outputNode.dataset.value = input2.dataset.value;
            }
        }

        function updateNandValue(nandNode) {
            const input1 = nodes.find(n => n.id === nandNode.dataset.input1);
            const input2 = nodes.find(n => n.id === nandNode.dataset.input2);
            
            if (input1 && input2) {
                const val1 = parseInt(input1.dataset.value);
                const val2 = parseInt(input2.dataset.value);
                const nandResult = ~(val1 & val2) & 1;
                nandNode.dataset.value = nandResult;
                
                // Find nodes that use this NAND as input and update them
                nodes.forEach(node => {
                    if ((node.dataset.input1 === nandNode.id || node.dataset.input2 === nandNode.id) && 
                        node.dataset.type === 'nand') {
                        updateNandValue(node);
                    }
                });
                
                // Update output nodes that use this NAND as input
                outputNodes.forEach(node => {
                    if (node.dataset.input1 === nandNode.id || node.dataset.input2 === nandNode.id) {
                        node.dataset.value = nandNode.dataset.value;
                    }
                });
            }
        }

        function updateConnections() {
            // Remove all existing connection lines
            connections.forEach(conn => conn.remove());
            connections = [];
            
            // Helper function to find a node in either array
            const findNodeById = (id) => {
                return nodes.find(n => n.id === id) || 
                       outputNodes.find(n => n.id === id);
            };
            
            // Redraw all connections for NAND nodes
            nodes.forEach(node => {
                if (node.dataset.input1) {
                    const input1 = findNodeById(node.dataset.input1);
                    if (input1) drawConnection(input1, node);
                }
                if (node.dataset.input2) {
                    const input2 = findNodeById(node.dataset.input2);
                    if (input2) drawConnection(input2, node);
                }
            });
            
            // Draw connections to output nodes
            outputNodes.forEach(output => {
                if (output.dataset.input1) {
                    const input1 = findNodeById(output.dataset.input1);
                    if (input1) drawConnection(input1, output);
                }
                if (output.dataset.input2) {
                    const input2 = findNodeById(output.dataset.input2);
                    if (input2) drawConnection(input2, output);
                }
            });
        }

        function drawConnection(from, to) {
            const connection = document.createElement('div');
            connection.className = 'connection';
            
            // Store the connected nodes' IDs
            connection.dataset.fromId = from.id;
            connection.dataset.toId = to.id;
            
            const fromX = parseFloat(from.dataset.x) + from.offsetWidth/2;
            const fromY = parseFloat(from.dataset.y) + from.offsetHeight/2;
            const toX = parseFloat(to.dataset.x) + to.offsetWidth/2;
            const toY = parseFloat(to.dataset.y) + to.offsetHeight/2;
            
            const dx = toX - fromX;
            const dy = toY - fromY;
            const length = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx) * 180 / Math.PI;
            
            connection.style.width = length + 'px';
            connection.style.left = fromX + 'px';
            connection.style.top = fromY + 'px';
            connection.style.transform = `rotate(${angle}deg)`;
            
            document.getElementById('game-container').appendChild(connection);
            connections.push(connection);
        }

        function addIntermediateNode() {
            const x = Math.random() * 800 + 50;
            const y = Math.random() * 100 + 50;
            const value = Math.round(Math.random());
            const node = createNode(x, y, value, 'nand');
            updateCircuitSerialization();
            return node;
        }

        function createOutputNodes() {
            const containerWidth = 900;
            const containerHeight = 600;
            createNode(containerWidth/2, containerHeight - 150, '?', 'output');
        }

        function setGoal(goal) {
            currentGoal = goal;
            resetGame();
            updateGoalDisplay();
        }

        function updateGoalDisplay() {
            const goalDisplay = document.querySelector('.goal-display');
            goalDisplay.textContent = GOALS.xor.description;
        }

        function checkCircuit() {
            const outputNode = outputNodes[0];
            if (!outputNode || outputNode.dataset.value === '?') return;

            const goal = GOALS.xor;  // We only have XOR now
            const inputs = nodes.filter(n => n.dataset.type === 'input')
                              .map(n => parseInt(n.dataset.value));
            
            // Find matching truth table entry
            const entry = goal.truthTable.find(e => 
                e.inputs.every((val, idx) => val === inputs[idx])
            );

            if (entry && parseInt(outputNode.dataset.value) === entry.output) {
                outputNode.classList.add('correct');
            } else {
                outputNode.classList.remove('correct');
            }
            
            // Update truth table after checking circuit
            updateTruthTable();
        }

        function resetGame() {
            nodes.forEach(node => node.remove());
            outputNodes.forEach(node => node.remove());
            connections.forEach(conn => conn.remove());
            nodes = [];
            outputNodes = [];
            connections = [];
            selectedNode = null;
            nextNodeId = 2; // Reset node ID counter

            // Initialize with input nodes and output node
            for (let i = 0; i < 2; i++) {
                const x = Math.random() * 800 + 50;
                const y = Math.random() * 100 + 50;
                const value = Math.round(Math.random());
                createNode(x, y, value, 'input');
            }
            createOutputNodes();
            updateGoalDisplay();
            updateCircuitSerialization();
        }

        // Add dragging state variables
        let isDragging = false;
        let currentX;
        let currentY;
        let initialX;
        let initialY;
        let dragTarget = null;

        function startDragging(e) {
            dragTarget = e.target;
            isDragging = true;
            
            const containerRect = document.getElementById('game-container').getBoundingClientRect();
            const nodeRect = dragTarget.getBoundingClientRect();
            
            // Calculate the offset of the mouse within the node
            initialX = e.clientX - nodeRect.left;
            initialY = e.clientY - nodeRect.top;
            
            dragTarget.classList.add('dragging');
            
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', stopDragging);
        }

        function drag(e) {
            if (!isDragging) return;
            
            e.preventDefault();
            
            const containerRect = document.getElementById('game-container').getBoundingClientRect();
            
            currentX = e.clientX - containerRect.left - initialX;
            currentY = e.clientY - containerRect.top - initialY;
            
            currentX = Math.max(0, Math.min(currentX, containerRect.width - dragTarget.offsetWidth));
            currentY = Math.max(0, Math.min(currentY, containerRect.height - dragTarget.offsetHeight));
            
            dragTarget.style.left = currentX + 'px';
            dragTarget.style.top = currentY + 'px';
            dragTarget.dataset.x = currentX;
            dragTarget.dataset.y = currentY;
            
            // Update connections when dragging
            updateConnections();
        }

        function stopDragging() {
            isDragging = false;
            if (dragTarget) {
                dragTarget.classList.remove('dragging');
                dragTarget = null;
            }
            document.removeEventListener('mousemove', drag);
            document.removeEventListener('mouseup', stopDragging);
        }

        function updateTruthTable() {
            console.log('Updating truth table...');
            const table = document.getElementById('truth-table-content');
            const goal = GOALS.xor;  // Use XOR directly since it's our only goal
            
            let html = '<table><tr><th>Input A</th><th>Input B</th><th>Target</th><th>Current</th></tr>';
            
            const inputNodes = nodes.filter(n => n.dataset.type === 'input')
                                   .sort((a, b) => parseFloat(a.dataset.x) - parseFloat(b.dataset.x));
            const outputNode = outputNodes[0];
            
            goal.truthTable.forEach(entry => {
                const isCurrentRow = inputNodes.length === 2 && 
                                   parseInt(inputNodes[0].dataset.value) === entry.inputs[0] && 
                                   parseInt(inputNodes[1].dataset.value) === entry.inputs[1];
                
                const currentOutput = isCurrentRow ? (outputNode ? outputNode.dataset.value : '?') : '-';
                
                html += `<tr class="${isCurrentRow ? 'current' : ''}">
                    <td>${entry.inputs[0]}</td>
                    <td>${entry.inputs[1]}</td>
                    <td>${entry.output}</td>
                    <td>${currentOutput}</td>
                </tr>`;
            });
            
            html += '</table>';
            table.innerHTML = html;
        }

        // Initialize
        createTooltip();
        resetGame();

        function findPaths(startNode) {
            const paths = [];
            
            function traverse(currentNode, currentPath = []) {
                currentPath = [...currentPath, currentNode];
                
                // Find all connected nodes
                let nextNodes = [];
                if (currentNode.dataset.type === 'input' || currentNode.dataset.type === 'nand') {
                    // Find connected NAND gates
                    nextNodes = nodes.filter(n => 
                        n.dataset.type === 'nand' && 
                        (n.dataset.input1 === currentNode.id || n.dataset.input2 === currentNode.id)
                    );
                    
                    // Find connected output nodes
                    const connectedOutputs = outputNodes.filter(n => n.dataset.connectedTo === currentNode.id);
                    nextNodes = [...nextNodes, ...connectedOutputs];
                }
                
                if (nextNodes.length === 0) {
                    // End of path
                    if (currentPath.length > 1) {
                        paths.push(currentPath);
                    }
                } else {
                    // Continue traversing each branch
                    nextNodes.forEach(nextNode => {
                        // Prevent cycles
                        if (!currentPath.includes(nextNode)) {
                            traverse(nextNode, currentPath);
                        }
                    });
                }
            }
            
            traverse(startNode);
            return paths;
        }

        // Track which balls have arrived at each node
        let ballArrivals = new Map();

        async function playAnimation() {
            const playBtn = document.getElementById('play-btn');
            playBtn.disabled = true;
            
            try {
                // Reset ball arrival tracking
                ballArrivals.clear();
                
                // Initialize all NAND nodes to track their inputs
                nodes.filter(n => n.dataset.type === 'nand').forEach(nand => {
                    ballArrivals.set(nand.id, new Set());
                });
                
                // Start balls from all input nodes simultaneously
                const inputNodes = nodes.filter(n => n.dataset.type === 'input');
                await Promise.all(inputNodes.map(node => sendBallFromNode(node)));
            } catch (error) {
                console.error('Animation error:', error);
            } finally {
                playBtn.disabled = false;
            }
        }

        async function sendBallFromNode(node) {
            console.log(`Sending ball from node: ${node.id}, type: ${node.dataset.type}`);
            // Flash the source node
            node.style.transform = 'scale(1.2)';
            await new Promise(resolve => setTimeout(resolve, 100));
            node.style.transform = '';
            
            // Find all children of this node
            const children = findChildNodes(node);
            console.log(`Children of node ${node.id}:`, children.map(child => child.id));
            
            // Send balls to all children simultaneously
            await Promise.all(children.map(async (child) => {
                const ball = createBall(node);
                await animateBallToNode(ball, node, child);
                
                if (child.dataset.type === 'nand') {
                    // Record this ball's arrival at the NAND gate
                    const arrivals = ballArrivals.get(child.id);
                    arrivals.add(node.id);
                    console.log(`Ball arrived at NAND node ${child.id}, arrivals:`, Array.from(arrivals));
                    
                    // If both inputs have arrived
                    if (arrivals.has(child.dataset.input1) && arrivals.has(child.dataset.input2)) {
                        console.log(`Both inputs arrived at NAND node ${child.id}`);
                        // Update NAND value
                        const input1 = nodes.find(n => n.id === child.dataset.input1);
                        const input2 = nodes.find(n => n.id === child.dataset.input2);
                        updateNandValue(child, input1, input2);
                        
                        // Send ball from this NAND node to its children
                        await sendBallFromNode(child);
                    }
                }
                
                ball.remove();
            }));
        }

        function findChildNodes(node) {
            if (node.dataset.type === 'input' || node.dataset.type === 'nand') {
                // Find NAND gates where this is input1 or input2
                return nodes.filter(n => 
                    n.dataset.type === 'nand' && 
                    (n.dataset.input1 === node.id || n.dataset.input2 === node.id)
                ).concat(
                    // Find output nodes connected to this NAND
                    outputNodes.filter(n => 
                        n.dataset.input1 === node.id || 
                        n.dataset.input2 === node.id
                    )
                );
            }
            return [];
        }

        async function animateBallToNode(ball, fromNode, toNode) {
            const startX = parseFloat(fromNode.dataset.x) + fromNode.offsetWidth/2 - 6;
            const startY = parseFloat(fromNode.dataset.y) + fromNode.offsetHeight/2 - 6;
            ball.style.left = startX + 'px';
            ball.style.top = startY + 'px';
            
            await new Promise(resolve => setTimeout(resolve, 100));
            
            const endX = parseFloat(toNode.dataset.x) + toNode.offsetWidth/2 - 6;
            const endY = parseFloat(toNode.dataset.y) + toNode.offsetHeight/2 - 6;
            ball.style.transition = 'all 0.5s ease-in-out';
            ball.style.left = endX + 'px';
            ball.style.top = endY + 'px';
            
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // Flash the destination node
            toNode.style.transform = 'scale(1.2)';
            await new Promise(resolve => setTimeout(resolve, 100));
            toNode.style.transform = '';
        }

        function createBall(startNode) {
            const ball = document.createElement('div');
            ball.className = 'ball';
            const x = parseFloat(startNode.dataset.x) + startNode.offsetWidth/2 - 6;
            const y = parseFloat(startNode.dataset.y) + startNode.offsetHeight/2 - 6;
            
            ball.style.left = x + 'px';
            ball.style.top = y + 'px';
            
            document.getElementById('game-container').appendChild(ball);
            return ball;
        }
    </script>
</body>
</html>  